---
typora-copy-images-to: Picture
---

# 补充

Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据（元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的。

## 1.Class类的对象

1. jvm为每个加载的类型（**包括类，接口，枚举**）都创建一个java.lang.Class的实例。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来。你可以通过Class类的一个静态方法得到这个实例的引用：public static Class forName(String className)；也可以通过任一对象的getClass()函数得到类对象的引用，getClass被声明在Object类中。

   ![image-20220210204129877](F:\笔记\JVM\Picture\image-20220210204129877.png)

2. 一般情况下每个类型的Class对象都是Singleton单例的（Class对象一般只会加载一次，每个类型生成一个Class对象），而且是类加载器+全限定类名作为唯一键。一般情况下JDK中的类都有固定的类加载器进行加载，但是由于双亲委派机制，可能会出现用一个特殊的自定义类加载器去打破的这个规则。

   假如你调用forName(“java.lang.Object”)，你会得到与java.lang.Object对应的类对象。你甚至可以通过这个函数 得到任何包中的任何已加载的类引用，只要这个类能够被加载到当前的名字空间。如果jvm不能把类加载到当前名字空间，forName就会抛出ClassNotFoundException。

3. 通过类对象的引用，你可以在运行中获得相应类存储在方法区中的类型信息，下面是一些Class类提供的方法：

   public String getName();

   public Class getSuperClass();

   public boolean isInterface();

   public Class[] getInterfaces();

   public ClassLoader getClassLoader();

   这些方法仅能返回已加载类的信息。getName()返回类的完整名，getSuperClass()返回父类的类对象，isInterface()判断是否是接口。getInterfaces()返回一组类对象，每个类对象对应一个直接父接口。如果没有，则返回一个长度为零的数组。

   getClassLoader()返回类加载器的引用，如果是由启动类加载器加载的则返回null。所有的这些信息都直接从方法区中获得。
   
4. 对类加载器的引用

   jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中，同时类的加载器也记录了它都加载了哪些类。

   jvm在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。这对jvm区分名字空间的方式是至关重要的。



## 2.Java对象的内存存储布局

首先申明：普通对象与数组对象的存储结构存在区别

1. 我们常用的HotSpot虚拟机中，对象在内存中的存储布局可以分为3块区域：对象头（header），实例数据（Instance Data）和对齐填充。

   ![image-20220210205420032](F:\笔记\JVM\Picture\image-20220210205420032.png)

   在HotSpot虚拟机的对象头包括2部分内容，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode），GC分代年龄（Eden区-->S0--S1--->老年代），锁状态标志，线程持有锁，偏向线程id，偏向时间戳等。这部分数据的长度在32位和64位的虚拟机中分别是32bit，64bit，官方称为**Mark Word**（运行时元数据）。

   对象头的另一部分是类型指针class pointer/Klass word，即对象指向它的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例。如果对象是一个数组，在对象头中还必须包含一块用于存放数组长度的数据，因为虚拟机可以用过不同对象的元数据信息确定Java对象的大小，但是数组的元数据中没有数组大小信息（数组对象的长度和类型是不固定的）。

2. 接下来的实例数据部分是对象真正存储着有效信息的内容，比如程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的还是在子类中自己定义的都会在此处记录下来。这部分的存储顺序会受到虚拟机默认的分配策略参数FieldAllocationStyle和字段在Java源代码中定义顺序的影响。

3. 第三部分对其填充并不是必然存在，也没有特殊含义，是为了保证对象的大小必须是8字节的整数的而预留的占位符，如果对象大小就是8字节的整数倍，该部分可以不存在，否则就需要对其填充来补全。

   总结一下图：

   ![image-20220210212552391](F:\笔记\JVM\Picture\image-20220210212552391.png)



## 3.对象是怎么定位的

我们以方法中的一个局部变量来举例，比如Object obj = new Object()。其中引用类型obj是在栈帧中的局部变量表中，实例对象本身放在JVM堆中，Java程序通过栈上的refrence数据来操作堆上的具体对象。由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机的实现而定的。目前主流的访问方式分为句柄和直接指针两种。

如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据（方法区中的元数据）的具体地址信息。

![image-20220210223250590](F:\笔记\JVM\Picture\image-20220210223250590.png)

如果使用直接指针访问，reference中存储的直接就是对象地址，堆中的每个对象的实例数据又会存储一个指向其类型数据（元数据）相关的信息相关的指针。

![image-20220210224147593](F:\笔记\JVM\Picture\image-20220210224147593.png)

这两种对象的访问方式各有优劣，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销。HotSpot虚拟机使用的时直接指针定位对象的方式，但是句柄方式定位对象在其他系统中也是十分普遍的。

## 4.JVM运行时数据区常见面试题

![image-20220212204908228](F:\笔记\JVM\Picture\image-20220212204908228.png)

![image-20220212204919043](F:\笔记\JVM\Picture\image-20220212204919043.png)

![image-20220212204929149](F:\笔记\JVM\Picture\image-20220212204929149.png)

## 5.常用JVM命令：

-XX:+HeapDumpOnOutOfMemoryError：当出现OOM时，生成堆中的dump文件





