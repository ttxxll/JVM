---
typora-copy-images-to: Picture
---

# 1.JVM和Java体系结构

## 1.相关概念

1. java是跨平台的语言：

   虽然各个平台的操作系统不一样，但是每个平台（操作系统）都实现了各自的JVM，java文件编译出来的.class文件在各个平台的对应的JVM上运行，然后JVM再将字节码解释/编译为对应平台上的机器指令，这样各个平台就都能执行Java程序了。

   也就是一次编译，到处运行。

![image-20211226201317631](F:\笔记\JVM\Picture\image-20211226201317631.png)

2. JVM是跨语言的平台：

   Java虚拟机根本不关心运行在其内部的程序到底使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，`只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集，符号表以及其他的辅助信息，它就是一个有效的字节码文件`，能够被虚拟机所识别并装在运行。

   Java虚拟机只与特定的二进制文件格式——.class文件格式所关联。class文件包含了`Java虚拟机指令集（或者称为字节码，Bytecodes）和符号表，还有一些其他辅助信息。`

![image-20211226200203377](F:\笔记\JVM\Picture\image-20211226200203377.png)

3. 字节码：

   我们平时说的java字节码，指的是用java语言编译成的字节码。但是不仅java文件能编译成字节码文件，Kotlin，Scala，Groovy的源文件也能编译成字节码文件，而且这些字节码文件都能在Jvm平台上执行。所以Java虚拟机平台能运行非Java语言编写的程序，那么字节码也不能仅仅指Java字节码，更准确的称呼是Jvm字节码。

   任何一门编程语言都需要转换为与平台相关的汇编指令，再将汇编指令转换成CPU可以识别执行的机器指令。java编译器javac并不是将java代码直接编译成与平台相关的汇编指令，而是编译成一种中间语言，即java的class字节码文件。字节码文件，顾名思义就是一个一个的字节。字节码文件里面村的并不是二进制，而是16进制，因为二进制太长了，一个字节要由8位二进制组成，所以用16进制表示，两个16进制就可以表示一个字节。java源码编译后的字节码文件是不能够直接被CPU执行的，那么该如何执行呢？答案是JVM，为了让java程序能够在不同的平台上执行，java官方提供了针对于各个不同平台的java虚拟机，JVM运行于硬件层之上，冰壁各种平台差异。javac编译后的字节码文件统一由JVM来加载，最后再转化成与硬件相关的机器指令被CPU执行。

   不同语言的编译器，都可以编译成字节码文件，这些字节码只要满足并包含Java虚拟机的内部指令集，符号表以及其他的辅助信息，它就是一个有效的字节码文件，能够被JVM识别并执行。

4. 多语言混合编程：

   Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。

   试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成。而且接口对每一层的开发者都是透明1的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。

   对这些运行于Java虚拟机之上，Java之外的语言，来自系统及的，底层的支持正在迅速增强。以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目，Nashorn引擎，InvokeDynamic指令，Java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展。

5. Java发展的重大事件

   2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机

   2018年，JDK11发布，LTS（Long Time Support，长期支持）版本的JDK，发布革命性的ZGC，调整JDK授权许可。

   ![image-20211226202838530](F:\笔记\JVM\Picture\image-20211226202838530.png)

   ![image-20211226202856638](F:\笔记\JVM\Picture\image-20211226202856638.png)

6. 虚拟机

   所谓虚拟机，就是一台虚拟的计算机，它是一款软件，用来执行一系列`虚拟计算机指令`。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

   - 大名鼎鼎的Visual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。
   - 程序虚拟机（高级语言虚拟机）的典型代表就是Java虚拟机，它专门为执行单个计算机程序而涉及，是为了解释运行某一个应用程序，我们需要的一个虚拟机的环境。`在Java虚拟机中执行的指令我们称为Java字节码指令。`

   无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。

7. Java虚拟机

   指的是高级语言虚拟机（high-level language virtual machine，HLL VM），其意义是实现高级语言的语义。

   VM既然被称为“机器”，一般认为输入是满足某种指令集架构（[instruction set architecture](http://en.wikipedia.org/wiki/Instruction_set)，ISA）的指令序列，中间转换为目标指令集架构的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标指令集架构可以是同一种，这是所谓same-ISA VM。

   Java虚拟机是一台执行Java字节码指令的虚拟计算机，它拥有独立的运行机制，其运行的字节码未必一定是由Java语言编译而成的。

   JVM的主要作用，就是提供了一个二进制字节码的运行环境，负责装在字节码到其内部，`解释/编译为对应平台上的机器指令执行`。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放到哪。

   JVM试运行在操作系统之上的，它与硬件没有直接交互。

   ![image-20211226204622179](F:\笔记\JVM\Picture\image-20211226204622179.png)

8. JDK, JRE, JVM

   JDK包含JRE，JRE包含JVM。

   JDk包含了javac编译器，将java文件编译成.class文件，这个也称为`前端编译器`。

   运行字节码文件时，需要JVM提供一个解释运行的环境，将class字节码解释/编译成计算机指令，这里的编译器，称为`后端编译器`。

   ![image-20211226204733272](F:\笔记\JVM\Picture\image-20211226204733272.png)

## 2.Jvm的整体结构

HotSpot VM是目前市面上高性能虚拟机的代表作之一，也是Oracle JDK和Open JDK公用的虚拟机。它采用解释器与即时编译器并存的架构。

在今天Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。

1. HotSpot虚拟机的内存结构图如下：

![image-20211226210755504](F:\笔记\JVM\Picture\image-20211226210755504.png)

2.  大致分析一下

   - Java虚拟机是解释运行字节码文件的，所以入口就是Class files；

   - 字节码文件会被类装载器子系统Class Loader，加载到内存中，生成一个大的Class对象。这个过程会涉及到：加载，链接，初始化，链接又会具体的分成三步。

   - 中间部分叫做运行时数据区Runtime Data Area，字节码文件经过类加载器加载到内存后，会在方法区生成一个大的Class实例。Java栈现在叫做虚拟机栈。`多个线程共享堆和方法区；虚拟机栈，本地方法栈和程序计数器是每个线程独有一份的。`

   - 执行引擎Execution Engine，又具体分为：

     解释器：字节码加载到内存后会将二进制字节码翻译成汇编指令，然后再由硬件将汇编指令转换成机器指令。解释器是由软件实现的，主要是为了实现同一份java字节码可以在不同的平台上解释运行，而将汇编指令转换成机器指令是由硬件直接实现的，这一步速度很快。解释器是保证响应时间的，一上来就针对字节码指令进行解释执行。

     JIT即时编译器：只有解释器的话，运行效果较差。针对字节码指令其中反复执行的热点代码，JIT会将字节码指令编译成机器指令，放到方法区缓存起来，下次直接调用。JIT编译器主要负责程序的性能。

     垃圾回收器：实现垃圾的自动回收

     主流的虚拟机都采用解释器解释执行和JIT即时编译并存的方式。

3.  Java代码执行流程

    ![image-20211226213300606](F:\笔记\JVM\Picture\image-20211226213300606.png)

## 3.JVM的架构模型

### 3.1.指令集的架构模型

1. 输入到Java编译器的指令流基本上是一种基于栈指令集架构。

   指令集的架构模型一般分为两种：基于栈的指令集架构，基于寄存器的指令集架构。

   HotSpot虚拟机除了PC寄存器之外，再没有包含其他的寄存器。

   HotSpot中任何操作都要经过一个入栈和出栈的操作，用栈来管运行，由此可见HotSpot它的执行引擎的架构就是基于栈的指令集架构。

2. 具体来说两种架构之间的区别

   零地址指令：

   ​	正常我们去做一个指令的执行的时候，指令需要具有两部分：地址和操作数。指令有一个地址部分的指令就叫做一地址指令，指令有两个地址部分的就叫做二地址指令。零地址指令没有地址部分，只有操作数。

   ​	因为执行操作时都是从栈顶出栈，地址部分默认的都是栈顶，所以不需要地址部分。

   基于栈架构的特点：

   - 设计和实现更简单，适用于资源有限的系统：Java程序的运行都是通过一个一个的方法来实现的，每执行一个方法，我们就可以理解成一个入栈操作，栈顶就是当前正在执行的方法，当前方法执行完后，再做一个出栈的操作，所以设计和实现较简单。
   - 避开了寄存器的分配难题：使用零地址指令方式分配
   - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
   - 不需要硬件支持，可移植性更好，更好实现跨平台。

   基于寄存器架构的特点：

   - 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机
   - 指令集架构则完全依赖硬件，可移植性差
   - 性能优秀和执行更高效
   - 花费更少的指令去完成一项操作。
   - 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令，而地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。

3. javap：反编译二进制字节码文件，得到的是Java字节码的对应的文本形式而已或者助记符形式的字节码指令。

   **Java源代码**

   ```java
   int i = 2;
   int j = 3;
   int k = i+l;
   ```

   **Java bytecode字节码指令**

   ![image-20211226231359641](F:\笔记\JVM\Picture\image-20211226231359641.png)

   ```java
   iconst_2  //常量2入栈
   istore_1
   iconst_3  //常量3入栈
   istore_2
   iload_1
   iload_2
   iadd	  //常量2，3出栈，执行相加
   istore_0  //结果5出栈
   ```

   注意那个iadd（表示整型加法）指令并没有任何参数。连源都没有指定，零地址指令是怎么用的呢？
   零地址意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构——没错，就是栈。上面的iconst_1、iconst_2两条指令，分别向一个叫做“求值栈”（evaluation stack，也叫做operand stack“操作数栈”或者expression stack“表达式栈”）的地方压入整型常量2、3。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶。istore_0指令从求值栈顶弹出一个值，并将值保存到局部变量区的第一个位置（slot 0）。
   零地址形式的指令集一般就是通过“基于栈的架构”来实现的。请一定要注意，这个栈是指“求值栈”，而不是与系统调用栈（system call stack，或者就叫system stack）。千万别弄混了。有些虚拟机把求值栈实现在系统调用栈上，但两者概念上不是一个东西。

   由于指令的源与目标都是隐含的，零地址指令的“密度”可以非常高——可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令要完成一件事情，一般会比二地址或者三地址指令许多更多条指令。

   上面Java字节码做的加法，如果用x86指令两条就能完成了：

   **x86指令**

   ```java
   mov  eax, 2  //将eax寄存器的值设为2
   add  eax, 3  //将exa寄存器的值加3
   ```

### 3.2.看一个例子

 **Java代码**

   ```java
   public class Demo {  
       public static void foo() {  
           int a = 1;  
           int b = 2;  
           int c = (a + b) * 5;  
       }  
   } 
   ```

**Java bytecode字节码指令**

通过javac编译，得到Demo.class。通过javap可以看到foo()方法的字节码是

```java
0:  iconst_1  
1:  istore_0  
2:  iconst_2  
3:  istore_1  
4:  iload_0  
5:  iload_1  
6:  iadd  
7:  iconst_5  
8:  imul  
9:  istore_2  
10: return 
```

**JVM中的执行过程**

   ![img](http://dl.iteye.com/upload/attachment/157335/f2629890-07dc-34f5-9102-9274e5dafffc.gif)

图中数字均以十六进制表示。其中字节码的一列表示的是**字节码指令的实际数值（16进制值）**，后面跟着的助记符则是其对应的文字形式（字节码指令）。标记为红色的值是相对上一条指令的执行状态有所更新的值。下同
说明：Java字节码以1字节为单元。上面代码中有11条指令，每条都只占1单元，共11单元==11字节。
程序计数器是用于记录程序当前执行的位置用的。对Java程序来说，每个线程都有自己的PC。PC以字节为单位记录当前运行位置里方法开头的偏移量。
每个线程都有一个Java栈，用于记录Java方法调用的“活动记录”（activation record）。Java栈以帧（frame）为单位线程的运行状态，每调用一个方法就会分配一个新的栈帧压入Java栈上，每从一个方法返回则弹出并撤销相应的栈帧。
每个栈帧包括局部变量区、求值栈（JVM规范中将其称为“操作数栈”）和其它一些信息。局部变量区用于存储方法的参数与局部变量，其中参数按源码中从左到右顺序保存在局部变量区开头的几个slot。求值栈用于保存求值的中间结果和调用别的方法的参数等。两者都以字长（32位的字）为单位，每个slot可以保存byte、short、char、int、float、reference和returnAddress等长度小于或等于32位的类型的数据；相邻两项可用于保存long和double类型的数据。每个方法所需要的局部变量区与求值栈大小都能够在编译时确定，并且记录在.class文件里。
在上面的例子中，Demo.foo()方法所需要的局部变量区大小为3个slot，需要的求值栈大小为2个slot。Java源码的a、b、c分别被分配到局部变量区的slot 0、slot 1和slot 2。可以观察到Java字节码是如何指示JVM将数据压入或弹出栈，以及数据是如何在栈与局部变量区之前流动的；可以看到数据移动的次数特别多。动画里可能不太明显，iadd和imul指令都是要从求值栈弹出两个值运算，再把结果压回到栈上的；光这样一条指令就有3次概念上的数据移动了。

对了，想提醒一下：Java的局部变量区并不需要把某个局部变量固定分配在某个slot里；不仅如此，在一个方法内某个slot甚至可能保存不同类型的数据。如何分配slot是编译器的自由。从类型安全的角度看，只要对某个slot的一次load的类型与最近一次对它的store的类型匹配，JVM的字节码校验器就不会抱怨。以后再找时间写写这方面。

### 3.3.总结

由于跨平台性的考量，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能基于寄存器设计。

优点是跨平台，指令集下，编译器容易实现。

缺点是性能下降，实现同样的功能需要更多的指令。



## 4.JVM的生命周期

1. 虚拟机的启动：

   Java虚拟机的启动是通过引导类加载器Bootstrap class loarder创建一个初始类initial class来完成的，这个类是由虚拟机的具体实现指定的。

2. 虚拟机的执行

   一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。

   程序开始执行时它才执行，程序结束时它就结束。

   执行一个所谓的Java程序时，真真正正在执行的其实是一个叫做Java虚拟机的进程。如果部署了3个web应用，那么可以使用3个虚拟机来执行，每个web应用都是一个虚拟机进程。应用里面可以再单独开辟线程做一些工作。

3. 虚拟机的退出

   有如下的几种情况：

   - 程序正常执行结束

   - 程序在执行过程中遇到了异常或错误而异常终止

   - 由于操作系统出现错误而导致Java虚拟机进程终止

   - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，结束当前程序的执行，将整个虚拟机进程断掉了。并且Java安全管理器也允许这次exit或halt操作。

     ![image-20211228212042671](F:\笔记\JVM\Picture\image-20211228212042671.png)

     JVM运行时数据区就对应着Runtime类，每个运行的JVM就对应着一个运行时环境，所以Runtime这个类是单例的，并且是**饿汉式**，就是直接创建出类的实例化；

     ![image-20211228212717333](F:\笔记\JVM\Picture\image-20211228212717333.png)

     

   - 除此之外，JNI Java Native Interface 规范描述了用JNI Invocation API 来加载或卸载Java虚拟机时，Java虚拟机的退出情况。

## 5.JVM发展历程

1. Sun Classic Vm

   是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。

   这款虚拟机内部只提供了解释器：没有JIT编译器，不是解释器编译器并存的架构。

   如果使用JIT编译器，需要进行外挂，而且解释器和编译器不能同时配合工作

   现在hotspot内置了此虚拟机。
   
2. SUN公司的 HotSpot VM

   ![image-20211229214224504](F:\笔记\JVM\Picture\image-20211229214224504.png)

3. BEA的JRockit

   ![image-20211229214524867](F:\笔记\JVM\Picture\image-20211229214524867.png)

4. IBM的 J9

   ![image-20211229214601013](F:\笔记\JVM\Picture\image-20211229214601013.png)

5. Taobao JVM

   ![image-20211229220050277](F:\笔记\JVM\Picture\image-20211229220050277.png)

   

6. Graal VM

   ![image-20211229220701658](F:\笔记\JVM\Picture\image-20211229220701658.png)

   

   ![image-20211229220405808](F:\笔记\JVM\Picture\image-20211229220405808.png)

   



​		