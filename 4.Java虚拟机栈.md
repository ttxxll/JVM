---
typora-copy-images-to: Picture
---

# 4.Java虚拟机栈

## 1.虚拟机栈概述

1. 背景

   基于跨平台性的考虑，Java的指令集是根据栈来设计的，由于不同平台CPU架构不同，为了实现跨平台，所以指令集不能设计为基于寄存器的，而是基于栈来设计指令集，因为栈的操作一般只有出栈和入栈的操作。

   基于栈的指令集的优点是跨平台，指令集小，编译器容易实现；缺点是相较于基于寄存器。的指令集，性能不高，实现同样的功能需要更多的指令。

2. 栈和堆大体介绍

   栈解决程序的运行问题，及程序如何执行，或者说如何处理数据，通过局部变量表，操作数栈这些结构来处理。堆解决的是数据存储的问题，即数据怎么放，放在哪儿，当然也不是全部。大体的数据是放在堆中，比如对象，但是像方法内的一些局部变量，其中基本数据类型就是放在栈中，引用数据类型栈中放的是引用地址。

3. Java虚拟机栈的介绍

   Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。Java虚拟机栈是线程私有的，每个线程都有一个独立的Java虚拟机栈，且Java虚拟机栈和线程的生命周期保持一战。它保存方法的局部变量（8种基本类型的，对象的地址引用）。

4. 栈的优点

   栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。

   JVM对Java栈的操作只有两个：

   - 每个方法执行时，伴随着进栈。
   - 方法执行后的出栈操作。

   对于栈来说不存在垃圾回收问题：栈溢出了，直接出栈即可，不需要复杂的GC算法专门回收垃圾。

## 2.栈中可能出现的异常

1. Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。

   - 1.如果采用固定大小的Java虚拟机栈：那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立指定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会排除一个StackOverflowError异常。

   - 2.如果采用的Java虚拟机栈是可以动态扩展的：当在尝试扩展Java虚拟机栈时发现无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对象的虚拟机栈，那么Java虚拟机将会抛出一个OutOfMemory异常。

      常见的场景：程序不断地进行递归调用，而且没有退出条件，就会不断导致进栈操作，发生栈溢出。

2. 演示一下：StackOverflowError异常

   ```java
   public class StackOverflowTest {
       public static void main(String[] args) {
           main(args);
       }
   }
   ```

   ![image-20220119232650381](F:\笔记\JVM\Picture\image-20220119232650381.png)

3. 设置栈内存大小：-Xss

   我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。
   

[官网资料](https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE)

![image-20220119233503026](F:\笔记\JVM\Picture\image-20220119233503026.png)

   演示代码：

   ```java
   public class XssTest {
       private static int count = 1;
   
       public static void main(String[] args) {
           System.out.println(count);
           count++;
           main(args);
       }
   }
   ```

   

   - 1.默认的线程栈空间大小时，输出的最大count是11418，可以大致认为函数调用的最大可达深度是11418。
   
     ![image-20220119234029714](F:\笔记\JVM\Picture\image-20220119234029714.png)
   
   - 2.设置线程栈空间小于默认值：输出的最大count是2473，因为线程栈空间大小设定的值变小了，函数调用深度也明显变小了。

     ![image-20220119234219526](F:\笔记\JVM\Picture\image-20220119234219526.png)

     ![image-20220119234226402](F:\笔记\JVM\Picture\image-20220119234226402.png)

     ![image-20220119234347954](F:\笔记\JVM\Picture\image-20220119234347954.png)

     
## 3.栈的存储单位：栈帧

1. 栈的基本构成单位：

   每个线程都有自己的栈，栈中的数据都是以栈帧为单位构成得到。在这个线程上正在执行的每个方法都各自对应一个栈桢，栈帧不停的出栈和入栈操作实现了栈的运行。栈帧是一块内存区域，是一个数据集，维系着方法执行过程中的各种数据信息。

2. 栈的运行原理

   JVM直接对Java栈的操作只有两个，就是对栈帧的**压栈**和**出栈**，遵循“先进后出”或“后进先出”原则。

   在一条活动线程中，一个时间点上，只会有一个活动的栈帧，即栈顶栈帧，这个栈帧被称为**当前栈帧Current Frame**，与当前栈帧相对应的方法就是**当前方法**，定义这个方法的类就是**当前类**。

   执行引擎运行的所有字节码指令只针对当前栈帧进行操作，如果在当前方法中调用了其他方法，会有新的栈帧被创建出来，并压栈成为新的当前栈帧。

   不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

3. 方法的结束方式分为两种：

   - 正常结束：return; 或者捕获异常

   - 异常结束：方法执行中出现未捕获的异常，以抛出异常的方式结束。

     ![image-20220120230531787](F:\笔记\JVM\Picture\image-20220120230531787.png)

     不管使用哪种方式结束，都会导致栈帧被弹出。

4. 栈帧的内部结构：栈帧内部可以划分成5部分结构

   ![image-20220129230634293](F:\笔记\JVM\Picture\image-20220129230634293.png)

   - 局部变量表（Local Variables）

   - 操作数栈（Operand Stack 或表达式栈）

   - 动态链接（Dynamic Linking 或指向运行时常量池的方法引用）

   - 方法返回地址（Return Address 或方法正常退出和异常退出的定义）

   - 其他附加信息
   
     ![image-20220120231823559](F:\笔记\JVM\Picture\image-20220120231823559.png)



## 4.局部变量表：Local Variables

### 4.1.概述

局部变量表也被称为局部变量数组或本地变量表。

定义为一个数字数组，主要用于存储**方法参数**和定义在方法体内的**局部变量**，这些数据类型包括各类基本数据类型，对象的引用，以及return address。

由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。

局部变量表所需的容量大小是在编译器确定下来的，并保存在方法的Code属性的LocalVariableTable数据项中。局部变量表的大小在运行期间不会改变。

方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套调用的次数上限就越大。对一个函数而言，它的参数和局部变量越多，局部变量表就会越大，栈帧越大，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会变少。

局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。

### 4.2.分析main方法的字节码

1. 演示代码：

   ```java
   public class LocalVariablesTest {
       public static void main(String[] args) {
           LocalVariablesTest test = new LocalVariablesTest();
           int num = 10;
           test.test1();
       }
   
       public void test1() {
           Date date = new Date();
           String name1 = "txl";
           String info = test2(date, name1);
           System.out.println(date + name1);
       }
   
       public String test2(Date dateP, String name2) {
           dateP = null;
           name2 = "okok";
           double weight = 120;
           char gender = '男';
           return dateP + name2;
       }
   }
   ```

2. 编译后，查看解析后的字节码指令：`javap -v LocalVariablesTest.class`

   ![image-20220125214757313](F:\笔记\JVM\Picture\image-20220125214757313.png)

3. 描述符descriptor: ([Ljava/lang/String;)V 描述了方法的参数类型是String[]，返回值是void

4. 访问标志flags: ACC_PUBLIC, ACC_STATIC 

   ![image-20220125220856352](F:\笔记\JVM\Picture\image-20220125220856352.png)

5. Code部分：字节码指令解析后的形式，前面的数字是字节码助记符的行号

6. LineNumberTable：表示字节码和源代码的对应关系

   ![image-20220125221346554](F:\笔记\JVM\Picture\image-20220125221346554.png)

7. 局部变量表

   第一个变量是方法参数args，类型是引用String []，用`[L`表示数组引用类型

   第二个变量是对象：LocalVariablesTest test = new LocalVariablesTest(); `L`表示引用类型

   第三个参数是int num = 10; `I`表示int基本类型

   其中Start代表这个变量创建的位置（字节码指令行号），Length表示这个变量作用域长度，整个Start + Length就代表这个变量的作用域范围。

   main方法的局部变量表最大槽数：3，这是在编译是就确定下来的。

![image-20220125215231417](F:\笔记\JVM\Picture\image-20220125215231417.png)

### 4.3.实例方法的局部变量表

1. 槽

   - 局部变量表最基本的参数单元是Slot（变量槽）
   - 局部变量表中存放编译器可知的各种基本数据类型（8种），引用类型reference，returnAddress类型的变量。
   - 在局部变量表里32位以内的类型占用一个slot（包括引用类型，returnAddress类型），64位的类型（long和double）占两个slot。

2. JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。

3. 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被赋值到局部变量表中的每一个Slot上。

4. 如果需要访问局部变量表中一个64bit的局部变量时，只需要使用前一个Slot的索引即可

5. 如果当前栈帧是由构造方法或者实例方法创建的（或者说当前栈帧对应的方法是一个构造方法或者实例方法），那么该对象的引用this将会存放在索引位0的slot处，放在局部变量表中，其余参数按照顺序向后放。

6. this可以粗略的理解为正在创建的对象，static方法是不能用this的。

   现在学了局部变量表后，对this的理解要更深入本质了。因为实例方法和构造方法的局部变量表中存放了一个该对象的引用类型this，而static方法的局部变量表中没有this变量。

   演示代码：

   ```java
   public class LocalVariablesTest {
   
       private int count = 0;
   
       public LocalVariablesTest() {
           System.out.println(count);
       }
   
       public static void main(String[] args) {
           LocalVariablesTest test = new LocalVariablesTest();
           int num = 10;
           test.test1();
       }
   
       public void test1() {
           Date date = new Date();
           String name1 = "txl";
           String info = test2(date, name1);
           System.out.println(date + name1);
       }
   
       public String test2(Date dateP, String name2) {
           dateP = null;
           name2 = "okok";
           double weight = 120;
           char gender = '男';
           return dateP + name2;
       }
   
       public void test3() {
           this.count++;
       }
   
       /**
        * 演示槽的复用
        */
       public void test4() {
           int a = 0;
           {
               int b = 0;
               b = a + 1;
           }
           int c = a + 1;
       }
   }
   ```

   

   ![image-20220125225623707](F:\笔记\JVM\Picture\image-20220125225623707.png)

   ![image-20220125225634150](F:\笔记\JVM\Picture\image-20220125225634150.png)

   ![image-20220125225641469](F:\笔记\JVM\Picture\image-20220125225641469.png)

7. 槽Slot的复用

   栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量的作用域不是整个方法的话，那么当过了其作用域后，**在其作用域之后申明的新的局部变量**就很有可能会复用过期的局部变量的槽位，从而达到节省资源的目的。

   演示代码：

   ```java
       /**
        * 演示槽的复用
        */
       public void test4() {
           int a = 0;
           {
               int b = 0;
               b = a + 1;
               // b的作用域只在这个代码块中，执行到代码块之外会被销毁
           }
           int c = a + 1;
       }
   ```

   局部变量表的最大槽数locals是3：按理说局部变量表应该有this, a, b, c这四个槽

   ![image-20220125230438244](F:\笔记\JVM\Picture\image-20220125230438244.png)

   局部变量表：

   ![image-20220125230139900](F:\笔记\JVM\Picture\image-20220125230139900.png)

   局部变量c复用了变量b的槽：

   ​	局部变量b的作用域是4 - 8，而局部变量c的作用域是12 - 13，所以创建c变量时，b变量已经失效销毁了，Slot2的位置已经没有变量了。所以c变量可以复用原先为b开辟的槽。



### 4.4.局部变量的初始化操作

1. 变量的分类

   - 按照数据类型分：基本数据类型， 引用数据类型。
   - 按照在类中生命的位置分：
     - 成员变量：在使用前都会经历一个初始化赋予默认值的操作
       - 类变量：linking的prepare阶段会给类变量赋默认值，之后的initialize阶段会收集代码进行显示的赋值
       - 实例变量：随着对象的创建，会在对空间中分配实例变量空间，并进行默认赋值
     - 局部变量：没有默认值，类加载阶段不会为其进行默认赋值操作，在使用前，必须显示的进行赋值操作！否则编译不通过。

2. 我们知道类变量在类加载过程中有两次初始化的阶段，第一次是在“准备阶段”，执行系统初始化赋予默认值，另一次是在“初始化”阶段，赋予程序员在代码中定义的初始值。

3. 局部变量不存在系统初始化阶段，所以必须我们人为的初始化后，才能使用。

4. 如下代码就是错误的：

   ```java
       void test5() {
           int a;
           System.out.println(a);
       }
   ```

   ![image-20220125232650728](F:\笔记\JVM\Picture\image-20220125232650728.png)

### 4.5.补充说明

在栈帧中，与性能调优最为密切的部分就是前面提到的局部变量表，局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。



## 5.操作数栈Operand Stack

### 5.1.介绍

- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，也可以称之为表达式栈。

- 操作数栈，在方法执行过程中，随着字节码指令的执行，往栈中写入数据或提取数据，即入栈/出栈操作。某些字节码指令将值压入操作数栈，某些字节码指令将操作数取出栈，使用完它们后再将结果压入栈。比如执行复制，交换，求和等操作。

- 执行引擎借助操作数栈来执行字节码，将字节码指令翻译成CPU认识的机器指令（所以也说**Java虚拟机的解释引擎是基于栈的执行引擎**），或者说操作数栈就是JVM执行引擎的一个工作区。当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，但此时栈帧中的操作数栈是空的（方法都还没执行，肯定不涉及压栈入栈的操作，但是有一个初始化的栈，也是数组实现的即有一个空数组）。

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需要的最大深度在编译期间就确定了，保存在方法的Code属性中。

  ![image-20220129203026538](F:\笔记\JVM\Picture\image-20220129203026538.png)

- 栈中的任何一个元素可以是任意的Java数据类型：32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度。类似局部变量表的槽单位。操作数栈虽然是用数组实现的，但是不能采用访问索引的方式来进行数据访问，而只能通过标准的入栈和出栈操作来完成一个数据访问。

- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。

- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。

### 5.2.补充知识

1. byte, short, char, boolean, int**无论是在操作数栈还是局部变量表中都是以int型来保存**。可能是因为从硬件方面考虑CPU一次处理32位比较高效。

   ​	这样说一下：局部变量表一个Slot槽能放一个byte, short, char, boolean, int类型的变量。两个Slot槽能放一个double，long类型的数据。所以向byte，short，char真的只占1字节，2字节，2字节吗？
   
   - byte一个字节，范围：[-2^(8-1)^, 2^(8-1)-1]，-128 ~ -1, 0 ~ 127
   - short两个字节，范围：[-2^(16-1), 2^(16-1)-1]， -32768 ~ 32767
   - int四个字节，范围：[-2^(32-1), 2^(32-1)-1]
   - long八个字节
   
   ```java
   byte i = 15;//byte类型会转成int类型进行入操作数栈，入局部变量表 
               //字节码
               //0 bipush 15：将byet类型15转成int类型入栈
               //2 istore_1：弹出栈顶元素15存入槽位为1的局部变量表中（槽位0的是this）
   
   short z = 200;//short类型会转成int类型进行入操作数栈，入局部变量表 
   			 //字节码
   			 //3 sipush 200：将short类型转成int类型入栈
    			 //6 istore_2：弹出栈顶元素存入槽位为2的局部变量表中
   
   int y = 800000;//int不会转型
   			   //字节码
   			   //7 ldc #2 <800000>：从常量池索引2的位置取出800000压入栈
    			   //9 istore_3：弹出栈顶元素800000存入槽位为3的局部变量表中。
   ```
   
   
   
2. 代码中写的变量类型是int，如果数值大小在byte或者short范围的话，还是会有byte->int或者short->int的转化操作，意思是一开始发现能用byte或short存储的话就用byte或short存储，入栈和入表时再转成int吗？

   ```java
   int a = 10;
   		//10 bipush 10
   		//12 istore 4
   int b = 800;
   		//14 sipush 800
   		//17 istore 5
   ```

   

### 5.3.代码跟踪演示

1. 演示代码：

```java
public class OperandStackTest {
    public static void main(String[] args) {
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
}
```

2. 相关字节码：`javap -v OperandStackTest.class`

![image-20220129211050500](F:\笔记\JVM\Picture\image-20220129211050500.png)

3. 根据字节码分析跟踪过程：

   ```java
       Code:
         stack=2, locals=4, args_size=1
            0: bipush        15 //将byet类型15转成int类型入栈
            2: istore_1		 //弹出栈顶元素15，并存入槽位为1的局部变量表中（槽位0的是this）
            3: bipush        8  //将byet类型8转成int类型入栈
            5: istore_2		 //弹出栈顶元素8，并存入槽位为2的局部变量表中（槽位0的是this）
            6: iload_1			 //加载局部变量表槽位为1的变量，入栈
            7: iload_2		     //加载局部变量表槽位为2的变量，入栈
            8: iadd			 //计算求和结果23压入栈
            9: istore_3		 //弹出栈顶元素23，并存入槽位为3的局部变量表中
           10: return
   
   ```

   - 0: bipush        15 // 将byet类型15转成int类型入栈

     2: istore_1		 //弹出栈顶元素15，并存入槽位为1的局部变量表中（槽位0的是this）

     ![image-20220129220251652](F:\笔记\JVM\Picture\image-20220129220251652.png)

   - 3: bipush        8  //将byet类型8转成int类型入栈
     5: istore_2		 //弹出栈顶元素8，并存入槽位为2的局部变量表中（槽位0的是this）

     ![image-20220129220356203](F:\笔记\JVM\Picture\image-20220129220356203.png)

   - 6: iload_1			 //加载局部变量表槽位为1的变量，入栈
   7: iload_2		     //加载局部变量表槽位为2的变量，入栈
     
     ![image-20220129220531450](F:\笔记\JVM\Picture\image-20220129220531450.png)
     
   - 8: iadd			 //计算求和结果23压入栈
     9: istore_3		 //弹出栈顶元素23，并存入槽位为3的局部变量表中

     ![image-20220129220659515](F:\笔记\JVM\Picture\image-20220129220659515.png)

   

### 5.4.分析一下有返回值的方法

1. 演示代码：

   ```java
public class ReturnValueTest {
    
    public int getSum() {
        int m = 10;
        int n = 20;
        int k = m + n;
        return k;
    }

    public void testGetSum() {
        int i = getSum();
        int j = 10;
    }
}    
   ```

2. 分析下`getSum`方法的字节码：

![image-20220129222513672](F:\笔记\JVM\Picture\image-20220129222513672.png)

- ireturn ：

  Oracle官方Specifications中对该字节码指令的描述：

  ![image-20220129222843689](F:\笔记\JVM\Picture\image-20220129222843689.png)

  关键信息：从当前栈帧的操作数栈中弹出值，**并推送到调用者（testGetSum）栈帧的操作数栈中**，如果当前方法的操作数栈还有其他值，那么会被丢弃。

3. 分析下`testGetSum`方法的字节码：

   ![image-20220129223441097](F:\笔记\JVM\Picture\image-20220129223441097.png)

   aload_0：加载局部变量表中槽位置为0的变量this到操作数栈

   invokevirtual #2 <com/chapter5/ReturnValueTest.getSum>：执行getSum方法，并且接收方法的返回值，入操作数栈

   istore_1：将返回值存入局部变量表槽1的位置。

### 5.5.栈顶缓存技术

Top-Of-Stack Cashing技术：

​	前面提到过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这也意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。

​	由于操作数式存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，CPU可以直接到寄存器中取数据，以此降低对内存的读/写次数，提升执行引擎的执行效率。

​     

## 6.动态链接（Dynamic Linking）

下面学习一下栈帧中的第三个部分：动态链接。

在有些地方会把方法返回地址，动态链接，附加信息统称为帧数据区。

 ![image-20220129230848986](F:\笔记\JVM\Picture\image-20220129230848986.png)

1. 大部分的字节码指令在执行的时候，都需要进行常量池的访问，帧数据区中存放着指向常量池的指针，帮助指令访问常量池。

2. 在Java源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。然后加载class文件到内存，生成Class实例对象放到方法区中，方法区中会有一个运行时常量池，就对应着class文件的常量池。

   ![image-20220130110827132](F:\笔记\JVM\Picture\image-20220130110827132.png)

   其中的#1，#2...这些符号就是**符号引用**。

3. 每一个栈帧内部都包含了一个指向**运行时常量池**中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。我们知道在Java源文件被编译成字节码文件时，所有要用到的变量和方法（包括其他类库中方法和变量的使用）引用都对应上一个符号引用保存在class文件的常量池中。当一个方法执行时，如果要用到其他类的方法或着变量，就会通过符号引用来“指向”在常量池中的该方法或变量。

   ![image-20220130135422460](F:\笔记\JVM\Picture\image-20220130135422460.png)

   ![image-20220130135628548](F:\笔记\JVM\Picture\image-20220130135628548.png)

   

   这种符号引用是一种相对的位置（在class文件种常量池的位置）概念，实际上并没有指向具体的变量和方法。在代码执行时，这种符号引用才会被动态链接成具体的方法引用。在这个过程中，会根据需要加载相关的其他类，并将变量符号（int a）转换为这些变量在运行时具体的存储结构的偏移量（地址值，就是直接引用）。

   方法和变量的这种运行时绑定的方式，使得当前方法种使用的其他类发生了更改也不会破坏当前方法的代码。因为使用到的其他类做了更改，我也会**动态链接到修改后的代码**。

4. 上述的理解（猜测）是根据Oracle官网的JVM Specification得到的

   ![image-20220130133627926](F:\笔记\JVM\Picture\image-20220130133627926.png)

   


## 7.方法的调用

1. 静态链接和动态链接：

   在JVM中，将符号引用转换为调用方法的直接引用的过程称为链接，也可以说绑定，转换过程就是对要调用的方法或者变量与所属的类型进行绑定的过程。根据这个转换过程是在编译期间确定下来还是运行期间确定下来的可以将分为静态链接和动态链接。

   - 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期间就确定下来且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接。
   - 动态链接：如果被调用的方法在编译期间无法确定下来，只能够在程序运行期间将调用方法的符号引用转换为直接引用。这种引用的转换过程具有动态性（使用的其他类发生了更改，会链接到修改后的代码），因此也称为动态链接。

2. 早期绑定和晚期绑定

   绑定是指对一个字段，方法或者类在符号引用被替换为直接引用的过程，这个过程仅发生一次。根据发生的阶段，分为早期绑定和晚期绑定。

   - 早期绑定：指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样依赖由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号转换为直接引用。
   - 如果被调用的方法在编译期间无法被确定下来，只能够在运行期间根据实际的类型，绑定相关的方法，这种绑定方式称为晚期绑定。

3. 随着高级语言的横空出世，类似于Java这样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，继承和堕胎等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。

   Java中很多方法其实都具备虚函数（运行期间才能确定下来类型）的特征，它们相当于C++语言中的虚函数（C++中需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。

4. 虚方法和非虚方法

   - 子类对象的多态性的使用前提：类的继承关系，方法的重写。
- 非虚方法：如果方法在编译期间就确定了具体的调用类型，这个类型在运行时是不可变的，这样的方法就称为非虚方法。静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法。私有方法，静态方法，final方法都不能被重写，这些方法的类型在编译器就确定下来了。
   - 虚方法：其他方法称为。
   
5. 相关字节码指令：

   虚拟机中提供了一下几条有关方法调用的指令：

   - invokestatic：调用静态方法，解析阶段确定唯一方法版本。
   - invokespecial：调用< init >构造器方法，私有方法，父类方法，解析阶段唯一确定方法版本
   - invokevirtual：调用所有虚方法（调用final方法也是用的这个指令）
   - invokeinterface：调用接口方法
   - invokedynamic：动态解析出需要调用的方法，然后执行。

   前四条指令是普通调用指令，固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令称为动态调用指令，支持用户确定方法版本。

   invokestatic指令和invokespecial指令调用的方法是非虚方法，其余的指令调用的是虚方法（final方法除外，它也是invokevirtual指令调用的）。

6. invokedynamic字节码指令：

   **JVM字节码指令集**一直比较稳定，一直到Java7才增加了一个invokedynamic指令，这是Java为了**在一定程度上实现动态类型语言**而做的一种改进。但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令才能直接生成。

   Java整体上是一种静态类型的语言：动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者的就是静态类型语言，反之就是动态类型语言。本质上，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息。

   lambda表达式的引入，使得Java语言在一定程度上具备了动态语言的特点。比如我们用lambda（匿名函数）表达式生成一个对象：调用哪个方法来生成的Func对象，要在运行时才能确定，对应invokedynamic指令。

   ```java
   @FunctionalInterface
   interface Func {
       public boolean fun(String param);
   }
   
   public class LambdaTest {
   
       public void lambda(Func func) {
           return;
       }
   
       public static void main(String[] args) {
           LambdaTest lambdaTest = new LambdaTest();
   
           //调用哪个方法来生成的Func对象，要在运行时才能确定，对应invokedynamic指令
           Func func = s -> {
               return true;
           };
   
           lambdaTest.lambda(func);
   
           Func func1 = new Func() {
               @Override
               public boolean fun(String param) {
                   return false;
               }
           };
       }
   }
   ```

   ![image-20220130153714687](F:\笔记\JVM\Picture\image-20220130153714687.png)

7. JVM执行重写的方法的大致过程：
   
- 找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C。
   - 如果在类型C中找到了与常量池中的描述符合的方法，再进行方法权限校验，如果通过则返回这个方法的直接引用，查找过程结束。如果进行方法权限校验不通过时，则返回：java.lang.IllegalAccessError异常。
- 如果没有在类型C中找到相符合的方法，那么会按照继承关系从下往上一次对C的各个父类进行查找相符合方法，如果始终没有找到合适的方法，说明这个方法没有重写也没有具体的实现，调用的是一个抽象方法，抛出：java.lang.AbstractMethodError异常。
   - IllegalAccessError异常介绍：程序视图访问或修改一个属性或调用一个方法，这个属性或方法没有权限方法。一般情况下在编译期间就会检查出来，但是如果发生在运行时就说明一个类发生了不兼容的改变。

8. 虚方法表

   方法表：

   - 针对方法调用动态分派的过程，虚拟机会在类的方法区建立一个虚拟方法表的数据结构。
- 针对invokeinterface指令来说，虚拟机会建立一个叫做接口方法表的数据结构（interface method table）。
  
   在面向对象的编程中，会频繁的使用到动态分派（invokevirtual），每次动态分派的过程都要重新在类的方法元数据中搜索符合的方法目标，会影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）使用该表来代替查找。每个类都有一个虚方法表，表中存放着各个方法的实际入口。
   
   如果子类继承了父类，但是某个父类的方法没有被子类重写，那么在子类的方法表里面该方法指向的是父类的方法的入口，子类不会重新生成一个方法，然后让方法表指向这个生成的方法。如果子类重写了父类的方法，那么子类这个被重写的方法在表中的索引和父类的该方法的索引是一致的。这样做的目的是为了快速查找，当在子类里面找不到一个方法索引为1的方法时，那么jvm会直接去父类查找方法索引为1的方法，不需要重新在父类里面遍历。
   
   ![image-20220130162236031](F:\笔记\JVM\Picture\image-20220130162236031.png)
   
   
   
   虚方法表什么时候被创建：虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始化值准备完毕后，JVM会把该类的方法表也从初始化完毕。
   
   
   
## 8.方法返回地址

当前方法的栈帧中有一块内存区域叫做方法返回地址，存放的时调用者的下一条将要执行的指令的地址。

![image-20220130163317757](F:\笔记\JVM\Picture\image-20220130163317757.png)

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法指令的下一条指令的地址。而通过异常退出（并且有异常处理机制try catch）时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

本质上，方法的退出就是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC计数器值等，让调用者方法继续执行下去。

正常完成出口和异常完成出口的区别在于：通过异常完成出口退出不会给它的上层调用者产生任何的返回值。

当一个方法开始执行后，只有两种方式可以退出这个方法：

- 执行引擎执行到方法返回的字节码指令return，此时会有返回值传递给上层的方法调用者，简称正常完成出口。

  一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn，freturn，dreturn以及areturn，另外还有一个return指令供声明为void的方法，实例初始化方法，类和接口的初始化方法使用。

- 在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理其，就会导致异常方法退出，简称异常完成出口。

  如果有响应的异常处理器（try catch），那么在方法执行过程中抛出的异常，会根据一个异常处理表来找到处理异常的代码，进行处理。

  如下：如果指令地址4~16发生了异常，那么找地址为19的指令来处理异常。

  ![image-20220130165110301](F:\笔记\JVM\Picture\image-20220130165110301.png)



## 9.一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。   

不一定有，要看虚拟机具体的实现。

## 10.栈的相关面试题

1. 距离栈溢出的情况：StackOverflowError

   一直在往虚拟机栈中加栈帧，也就是一直在调用方法，生成栈帧，调用的方法没有退出。

   通过-Xss可以设置栈的大小，当在尝试扩展Java虚拟机栈时发现无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对象的虚拟机栈，那么Java虚拟机将会抛出一个OutOfMemory异常。

2. 调整栈的大小，就能保证不出现栈溢出了吗

   不能保证，增大栈的大小只能增加容纳栈帧的数量，增加调用的次数。

3. 分配的栈内存越大越好吗？

   整个内存空间是有限的，栈内存越大，栈的数量就越少，并发上线越低，其他内存空间也会被挤占。

4. 垃圾回收是否会涉及到虚拟机栈？

   不涉及，虚拟机栈可能出现Error：StackOverflowErro，但是不会出现GC。对于栈来说只有出栈和入栈两种操作，栈溢出了直接出栈即可，不需要复杂的GC算法专门回收垃圾。

5. 方法中定义的局部变量是否线程安全。

   什么是线程安全：如果只有一个线程才可以操作数据，则必是线程安全的。如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。

   方法内定义的局部变量如果是方法内产生，方法内消亡的话，则是线程安全。

   如果方法内定义的局部变量来自外部，或者会返回出去，那就是线程不安全的，如下两个例子：

   ![image-20220130213237483](F:\笔记\JVM\Picture\image-20220130213237483.png)

   

   

   

   

   

   

   

   


​      

   